// 自作VST用のインクルードファイル
#include "processor.h"
#include "myvst3def.h"
#include "myvst3fuid.h"
#include "fmath.h"
#include "filter.h"
#include "converter.h"

// VST3作成に必要なの名前空間を使用
namespace Steinberg {
	namespace Vst {


		// ============================================================================================
		// コンストラクタ
		// ============================================================================================
		MyVSTProcessor::MyVSTProcessor()
		{
			// コントローラーのFUIDを設定する
			setControllerClass(ControllerUID);
		}

		// ============================================================================================
		// クラスを初期化する関数
		// ============================================================================================
		tresult PLUGIN_API MyVSTProcessor::initialize(FUnknown* context)
		{
			// まず継承元クラスの初期化を実施
			tresult result = AudioEffect::initialize(context);
			if (result == kResultTrue)
			{
				// 入力と出力のAudioBusを追加する
				addAudioInput(STR16("AudioInput"), SpeakerArr::kMono);
				addAudioOutput(STR16("AudioOutput"), SpeakerArr::kMono);

				// 入力のEventBusを追加する
				addEventInput(STR16("Event Input"), 1);

				// 以下固有の初期化を実施
				ratio = 1.0f;
				threshold = 1.0f;
				makeupGain = 0.0f;
				attackTime = 5.0f;
				releaseTime = 100.0f;
				kneeSize = 0.0f;
				confusion = 0.0f;
				smoothnessVariation = SmoothnessVariation::S640;
			}

			// 初期化が成功すればkResultTrueを返す
			return result;
		}


		tresult PLUGIN_API MyVSTProcessor::setBusArrangements(SpeakerArrangement* inputs, int32 numIns, SpeakerArrangement* outputs, int32 numOuts)
		{
			// inputとoutputのバスが1つずつで、かつinputとoutputの構成がモノラルの場合
			if (numIns == 1 && numOuts == 1 && inputs[0] == SpeakerArr::kMono&& outputs[0] == SpeakerArr::kMono)
			{
				return AudioEffect::setBusArrangements(inputs, numIns, outputs, numOuts);
			}

			// 対応していないバス構成の場合、kResultFalseを返す。
			return kResultFalse;
		}

		tresult PLUGIN_API MyVSTProcessor::setupProcessing(ProcessSetup &setup)
		{
			sampleRate = setup.sampleRate;
			//inputRMS.setSampleRate(sampleRate);

			return true;
		}

		// ============================================================================================
		// 音声信号を処理する関数
		// ============================================================================================
		tresult PLUGIN_API MyVSTProcessor::process(ProcessData& data)
		{
			// パラメーター変更の処理
			// 与えられたパラメーターがあるとき、dataのinputParameterChangesに
			// IParameterChangesクラスへのポインタのアドレスが入る
			if (data.inputParameterChanges != NULL)
			{
				// 与えられたパラメーターの数を取得
				int32 paramChangeCount = data.inputParameterChanges->getParameterCount();

				// 与えられたパラメーター分、処理を繰り返す。
				for (int32 i = 0; i < paramChangeCount; i++)
				{
					// パラメーター変更のキューを取得
					// (処理するサンプル内に複数のパラメーター変更情報がある可能性があるため、
					// キューという形になっている。)
					IParamValueQueue* queue = data.inputParameterChanges->getParameterData(i);
					if (queue != NULL)
					{
						// どのパラメーターが変更されたか知るため、パラメーターtagを取得
						int32 tag = queue->getParameterId();

						// 変更された回数を取得
						int32 valueChangeCount = queue->getPointCount();
						ParamValue value;
						int32 sampleOffset;

						// 最後に変更された値を取得
						if (queue->getPoint(valueChangeCount - 1, sampleOffset, value) == kResultTrue)
						{
							// tagに応じた処理を実施
							switch (tag)
							{
							case PARAM_RATIO_TAG:
								// ratioを変更する
								// 1.0 ~ 60.0
								ratio = 1.0f + (value * 59.0f);
								break;
							case PARAM_THRESHOLD_TAG:
								// thresholdを変更する
								// -60.0 ~ 0.0 dB
								threshold = -60.0f + (value * 60.0f);
								break;
							case PARAM_MAKEUP_GAIN_TAG:
								// makeup gainを変更する
								// 0.0 ~ 24.0 dB
								makeupGain = value * 24.0f;
								break;
							case PARAM_ATTACK_TIME_TAG:
								// attack timeを変更する
								// 0.01 ~ 999.99 ms
								attackTime = 0.01f + value * 999.98f;
								break;
							case PARAM_RELEASE_TIME_TAG:
								// release timeを変更する
								// 0.01 ~ 999.99 ms
								releaseTime = 0.01f + value * 999.98f;
								break;
							case PARAM_KNEE_SIZE_TAG:
								// knee size を変更する
								// 0.0 ~ 24.0 dB
								kneeSize = value * 24.0f;
								break;
							case PARAM_CONFUSION_TAG:
								// confusion を変更する
								// GUI -> 0.00 ~ 1.00
								// 0.00 ~ 10.0 dB / ms
								// 指数的に動かしたいのでマッピング
								value = Converter::mySlopeMapper1(value, 0.001f, 6.0f);
								confusion = 10.0f * 1000.0f * value / sampleRate;
								break;
							case PARAM_SMOOTHNESS_TAG:
								// smoothness を変更する
								// 渡される value は normalized
								// item の index は (int)( value * (float)(numItems - 1) + 0.1f(誤差補正用) ) で求められる
								smoothnessVariation = (SmoothnessVariation)((int)(value * (float)(numSmoothnessVariations - 1) + 0.1f));
								break;

								//case PARAM_DEPTH_TAG:
								//	// depthを変更する。
								//	depth = value;
								//	break;
								//case PARAM_SPEED_TAG:
								//	// freqを変更する。
								//	// RangeParameterで作成されたパラメーターも、プロセッサクラスに渡されるときは
								//	// 0.0～1.0となってしまう。
								//	// 自分で各RangeParameterに応じた範囲を設定する必要がある。
								//	freq = (29.5f * value) + 0.5f; // 0.5～30.0の間に変更
								//	break;
								//case PARAM_TYPE_TAG:
								//	// typeを変更する。
								//	// StringListParameterで作成されたパラメーターも、プロセッサクラスに
								//	// 渡されるときは0.0～1.0となってしまう。
								//	// 今回はリスト数は3つなので、Volume…0.0f、Tremolo…0.5f、Panning…1.0fとなる。
								//	// リストの数が4つの場合、0.0f、0.333…、0.666…、1.0fとなる。
								//	// 「1.0f / (リストの数 - 1)」で求められる。
								//	type = (int32)(value * 2.0f);
								//	break;
							}
						}
					}
				}
			}

			// 入力・出力バッファのポインタをわかりやすい変数に格納
			// inputs[]、outputs[]はAudioBusの数だけある(addAudioInput()、addAudioOutput()で追加した分だけ)
			// 今回はAudioBusは1つだけなので 0 のみとなる
			// channelBuffers32は32bit浮動小数点型のバッファで音声信号のチャンネル数分ある
			// モノラル(kMono)なら 0 のみで、ステレオ(kStereo)なら 0(Left) と 1(Right) となる
			Sample32* inL = data.inputs[0].channelBuffers32[0];
			//Sample32* inR = data.inputs[0].channelBuffers32[1];
			Sample32* outL = data.outputs[0].channelBuffers32[0];
			//Sample32* outR = data.outputs[0].channelBuffers32[1];

			// numSamplesで示されるサンプル分、音声を処理する
			for (int32 i = 0; i < data.numSamples; i++)
			{

				// 入力信号をフィルタにかけて音圧を計算
				// ピークが0.637程度なので増幅する
				float inputLevel = 1.569858f;
				switch (smoothnessVariation) {
				case S32:
					inputLevel *= inputSmoothing32->process(inL[i], sampleRate);
					break;
				case S640:
					inputLevel *= inputSmoothing640->process(inL[i], sampleRate);
					break;
				case S3200:
					inputLevel *= inputSmoothing3200->process(inL[i], sampleRate);
					break;
				}

				// level to decibel
				// -120.0 ~ 
				float inputGain;
				if (inputLevel < 0.000001f)
					inputGain = -120.0f;
				else
					inputGain = Converter::levelToDecibel(inputLevel);

				const float inputDelta = inputGain - lastInputGain;
				lastInputGain = inputGain;

				// 出力を計算（attack, release未適用）
				// 活性化関数でkneeを作る
				// 活性化関数をmaxでクランプしない場合, deltaが負になるため
				// 逆方向の圧縮がかかる
				/*
				const float targetCompressionRatio = 1.0f - 1.0f / ratio;

				const float surplus = inputGain - threshold;

				// 0.0 ~ 1.0
				const float ratioIntensity = std::max(0.0f, Converter::activation(surplus, 0.1f));
				const float compressionRatio = ratioIntensity * targetCompressionRatio;
				const float	delta = surplus * compressionRatio;
				const float	outputGain = inputGain - delta;

				// diffrence between uncompressed and compressed
				float reductionGain = inputGain - outputGain;

				// attack, release を適用
				const float attackWeight = 0.5f * Converter::activation(surplus, 100.0f) + 0.5f;
				const float releaseWeight = 1.0f - attackWeight;
				const float compressionTransferTime = attackWeight * attackTime + releaseWeight * releaseTime;
				const float transferRate = 1000.0f / (compressionTransferTime * sampleRate);
				const float reductionGap = reductionGain - lastReductionGain;
				const float reductionDelta = transferRate * reductionGap;

				reductionGain = lastReductionGain + reductionDelta;
				*/
				const float compressionRatio = 1.0f - 1.0f / ratio;

				const float surplus = inputGain - threshold;

				// ratio がどの程度適応されるか
				// 0.0 ~ 1.0
				//const float ratioIntensity = 0.5f + 0.5f * fminf(fmaxf(-1.0f, Converter::flexibleActivation(surplus - 0.5f * kneeSize, 0.5f * kneeSize, kneeLinearity)), 1.0f);
				//const float ratioIntensity = fminf(fmaxf(0.0f, surplus / kneeSize), 1.0f);
				//const float compressionRatio = ratioIntensity * targetCompressionRatio;
				float  targetOutputGain;

				if ((float)kneeSize < surplus) { // above knee
					targetOutputGain = inputGain - compressionRatio * surplus;
				}
				else if (fabsf(surplus) <= (float)kneeSize) { // in knee
					targetOutputGain = inputGain - compressionRatio * fmath::pow(surplus + (float)kneeSize, 2.0f) / (4.0f * kneeSize);
					//inputGain + (1 / cRatio - 1) * pow(inputGain - cThreshold + cKneeWidth / 2, 2) / (2 * cKneeWidth);
				}
				else { // below knee
					targetOutputGain = inputGain;
				}

				const float	targetReductionGain = inputGain - targetOutputGain;

				// attack time, release time から 圧縮量の変化率 transferRate を計算
				// 活性化関数で attack time, release time の切り替わりを smoothing する
				const float attackWeight = 0.5f * fminf(fmaxf(-1.0f, inputDelta / confusion), 1.0f) + 0.5f;
				const float releaseWeight = 1.0f - attackWeight;
				const float compressionTransferTime = attackWeight * attackTime + releaseWeight * releaseTime;

				// if transfer rate is greater than 1.0, it will crash
				const float transferRate = fminf(1000.0f / (compressionTransferTime * sampleRate), 0.999999f);

				const float reductionGap = targetReductionGain - lastReductionGain;
				const float reductionDelta = transferRate * reductionGap;
				const float reductionGain = lastReductionGain + reductionDelta;

				// 音量変化を抑えるためにローパスに通す
				//compressionGain = outFilter.Process(compressionGain);

				lastReductionGain = reductionGain;

				float outputLevel = Converter::decibelToLevel(inputGain + makeupGain - reductionGain);

				//outputLevel = outputSmoothing240->process(outputLevel, sampleRate) * 1.569858f;

				outL[i] = inL[i] * outputLevel;

				// GUI表示用変数の更新
				if (i == 0) {
					constexpr float scale = 1.0f / 60.0f;
					// -60.0 ~ 0.0 db
				}

			}


			// -60.0 ~ 0.0 db
			constexpr float scale = 1.0f / 60.0f;
			const float guiInputGain = 1.0f + lastInputGain * scale;
			const float guiOutputGain = 1.0f + (lastInputGain + makeupGain - lastReductionGain) * scale;
			const float guiReductionGain = lastReductionGain * scale;

			// パラメーターのフィードバックの処理
			// 音声処理中に変更されたパラメーターがある時、dataのoutputParameterChangesに
			// 変更を設定することで、パラメーター操作クラスに値をフィードバックできる

			// フィードバック用のIParameterChangesクラスのポインタを取得
			IParameterChanges* outParamChanges = data.outputParameterChanges;

			if (outParamChanges) // 正常にポインタが取得出来たか確認
			{
				// フィードバックするパラメーターを追加するとともにパラメーター値変更用のキューを取得
				// (処理するサンプル内に複数回パラメーター変更情報がある可能性があるため、
				// キューという形になっている。)
				int32 index = 0;  // 何番目のパラメーターかを設定(0から順に増やす)
				IParamValueQueue* paramQueue = outParamChanges->addParameterData(PARAM_INPUT_LEVEL_TAG, index);

				if (paramQueue)
				{
					// フィードバックする値を設定する
					int32 queueIndex = 0;
					paramQueue->addPoint(0, guiInputGain, queueIndex); //feedbackValueはフィードバックする値とする
				}

				index = 1;  // 何番目のパラメーターかを設定(0から順に増やす)
				paramQueue = outParamChanges->addParameterData(PARAM_OUTPUT_LEVEL_TAG, index);

				if (paramQueue)
				{
					// フィードバックする値を設定する
					int32 queueIndex = 0;
					paramQueue->addPoint(0, guiOutputGain, queueIndex); //feedbackValueはフィードバックする値とする
				}

				index = 2;  // 何番目のパラメーターかを設定(0から順に増やす)
				paramQueue = outParamChanges->addParameterData(PARAM_REDUCTION_LEVEL_TAG, index);

				if (paramQueue)
				{
					// フィードバックする値を設定する
					int32 queueIndex = 0;
					paramQueue->addPoint(0, guiReductionGain, queueIndex); //feedbackValueはフィードバックする値とする
				}
			}

			// 問題なければkResultTrueを返す(おそらく必ずkResultTrueを返す)
			return kResultTrue;
		}


	}
} // namespace SteinbergとVstの終わり
